* {
    box-sizing: border-box;
}

section *,
article * {
    margin-bottom: 10px;
}

/*https://caniuse.com/  - використовуй щоб перевірити елементи, теги, псевдокласи, стилі, параметри на сумісність з браузерами, підтримка різними версіями браузерами */


/*:first-child - обирає перший дочірній елемент батьківського елемента*/
section :first-child {
    color: red;
}

/*:last-child - обирає останній дочірній елемент батьківського елемента*/
section :last-child {
    color: red;
}

/*:first-of-type - обирає перші дочірні елементи кожного типу (перший дів, перший параграф) батьківського елемента*/
section :first-of-type {
    background-color: aquamarine;
}

/*:last-of-type - обирає останні дочірні елементи кожного типу (перший дів, перший параграф) батьківського елемента*/
/*селектор і псевдоклас пишем через пробіл щоб обрати елементи в середині Секції, тобто серед потомків*/
section :last-of-type {
    background-color: aquamarine;
}

/*якщо селектор і псевдоклас написати без пробіла то псвдоклас застосується до самого елемента, або такого ж типу елементів на одному рівні*/
section p:last-of-type {
    font-style: italic;
}


/*а тут не відбудеться нічого, тому що у нас в секції на одному рівні з div першим елементом є параграф, тобто ми хочему стилізувати те, чого не існує, треба б ути уважними з цим*/
div:first-child {
    color: yellow;
}

/*:nth-child(parameter) - вибирає кожен якийсь (надцятий, як ми вкажемо в параметрах) дочірній елемент. 
:nth-child(2n) - вибере парний (кожен другий) елемент за наст. схемою
0 : 2*0=0
1 : 2*1=2
2 : 2*2=4

:nth-child(2n + 1) - вибере непарний (кожен другий) елемент за наст. схемою
0 : 2*0+1=1
1 : 2*1+1=3
2 : 2*2+1=5

:nth-child(7) - вибере лише сьомий дочірній елемент

:nth-child(3n) - вибере кожен третій дочірній елемент за наст.схемою
0: 3*0 = 0
1 :3*1 = 3
2 :3*2 = 6

:nth-child(3n + 2) - вибере кожен третій дочірній елемент починаючи з другого

*/
section :nth-child(2n) {
    color: grey;
}

section :nth-child(2n + 1) {
    color:chartreuse;
}

section :nth-child(7) {
    background-color: blue;
}

section :nth-child(3n) {
    border: 1px solid olivedrab;
}

section :nth-child(3n + 2) {
    border-left: 5px solid olivedrab;
}

article p:first-of-type {
    font-style: italic;
}

article :last-child {
    font-weight: 900;
}

/*:not() - вибирає всі дочірні елементи які не відповідають вказаним умовам*/

/*вибрати всі дочірні абзаци артікла які не мають класу .classy*/
article p:not(.classy) {
    color: inherit
}

/*вибрати всі дочірні абзаци артікла які не є параграфами*/
body :not(p) {
    color: inherit;
}

/* :is() - приймає як аргумент будь яку кільькість селекторів до яких може бути застосовані однакові стилі, це допомагає зменшити і оптимізувати код*/


/*тобто застосовуємо ховер до всіх h2 містяться в section,article,body*/
/*це те саме що написати так
section h2:hover,
article h2:hover,
body h2:hover {
    color: red;
    cursor: pointer;
}
    але через is() коротше
*/
:is(section,article,body) h2:hover {
    color: red;
    cursor: pointer;
}


/*:has() - вибере ті елементи після яких є параграф, тобто задає стилі до попередній елементів від того що в параметрі has або батьківському елементу що його містить*/
article :has(+ p) {
    margin-left: 20px;
}

/*h2:has(+ p) - вибирає той h2 після якого одразу йде параграф*/

h2:has(+ p) {
    text-decoration:line-through;
}

/*section:has(> div) - знаходить ті теги section, які безпосередньо містять дочірній елемент div, при цьому стилі застосовуються до всього батьківсього елемента, тоюто до всього section*/
section:has(> div) {
    text-decoration:underline;
}

/*для познач кореневого елемента, туди можна писати змінні, якісь загальні параметри, які ми прописуємо для html xчи body, але документ може бути написаний в xml і якщо все прописати в псевдоклас то воно саме буде все підставляти в той рутовий елемент яким написано розмітку*/
:root {
    --font-size: 18px;

}